# interval, timer 
# conaact, concatMap
# merge, mergeMap
# exhaustMap
# switchMap
# debounceTime => waits untill the stream is stabled for given time
# distinctUntilChanged
# use object/array destructuring
# use spread operators
# .pipe(...catchError()) throwError both should return obesrvable
#  inside pipe everything must return obesrvable
#  Observable.create(observer => {
      observer.next(some value),
      observer.error(throw error), //error and complete are mutually exclusive
      observer.complete()
    })
    
    const http$ = Observable.create( observer => {
            fetch('api/courses')
            .then(response => {
                  return response.json();
            })
            .then(body => {
                  observer.next(body);
                  observer.complete();
            })
            .catch(err => {
                  observer.error(err);
            })
      });
      
# <table *ngIf="(lessons$ | async) as lessons" >
      <tr *ngFor="let lesson of lessons">
            <td>{{lesson.title}}</td>

# shareReplay
      beginnerCourses$: Observable<Course[]>;
      advancedCourses$: Observable<Course[]>;
      
      const courses$ = http$.pipe(
            map(res => Object.values(res["payload"])),
            shareReplay()
      );
      
      this.beginnerCourses$ = courses$
            .pipe(
                  map((courses) =>courses.filter(course => course.category == 'BEGINNER'))
            ); //subscribe this in HTML
            
      this.advancedCourses$ = courses$
            .pipe(
                  map((courses) =>courses.filter(course => course.category == 'ADVANCED'))
            ); //subscribe this in HTML     

# reactive form auto save
      this.form.valueChanges.pipe(
                  filter(() => this.form.valid),
                  concatMap(changes => this.saveCourse(changes)) //saveCourse is http call
           ).subscribe();
      
      
      
      
      
      
      
      
