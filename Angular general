* Confusing terms:
  1. ngRoute --> module used for routing
  2. $routeProvider  --> used for route configuration(.when, .otherwise)
  3. $route --> can be used for route reload
  4. $routParams --> used for passing parameters

* We can check if some property is undefined 
  ng-show = "myproperty==undefined"

* Prefixing $ or ng, with any property or function denotes that it belongs to Angular.

* $scope vs $rootScope: 
  $rootScope is available globally(to all controller) whereas $scope is only available to the controller that has created it.

* href - we can use # to point to the root folder
  <a href='#/home'>home</a> <-- this can load another html template inside index.html

* Remove # from the url: http://loacahost:1124/index.html#/home
  1. $locationProvider.html5Mode(true) <-- enable html5 routing 
  2. Remove # symbol from all the links
  3. Include URL rewrite rule in web.config file
    <system.webServer>
      <rewrite>
        <rules>
          <rule name="RewriteRules" stopProcessing="true">
            <match url=".*" />
            <conditions logicalGrouping="MatchAll">
              <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
              <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
              <add input="{REQUEST_URI}" pattern="^/api"  negate="true" />
            </conditions>  
          </rule>
        </rules>
      </rewrite>
  4. add <base href="/">

* Using <ng-view></ng-view> directive we can load partial template.

* Routing feature: we need to add 'angular-route-min.js' file. All routing features are persent in different module 'ngRoute', so we have to set dependency with it and along with this we have to use 'config' method to provide configurations
  var app = angular.module('mymodule',['ngRoute'])
                    .config(function($routeProvider){
                      $routeProvider.when('/home',{
                        templateUrl:'templates/home.html'
                        controller: 'homectrl'
                      })
                      .when(...)
                      .otherwise({
                          redirectTo: '/homepage'
                        })
                    }).controller('homectrl', function($scope){----});
--> otherwise is a method which will get called in case of no route match.

--> using $routeParamas we can pass parameters to the service
  
  .config(function($routeProvider){
                      $routeProvider.when('/students/:id',{
                        templateUrl:'templates/studentDetail.html'
                        controller: 'studentCtrl'
                      })
                      
  .controller('studentCtrl', function($scope, $http, $routeParams){
      $http({
        url: 'http://ssdsd',
        params: {id: $routeParams.id},
        method: 'get'
      }).then(function(res){$scope.student = res.data});
    })                    
  
  --> Routes are by default case-sensetive, if we want to make it case-in-sensetive we can set
  caseInsensetiveMatch: true in when method;
   If we want all the routes to be case-in-sensetive then we can do it like belwo
   $routeProvider.caseInsensetiveMatch = true;
   
  --> for inline templatres we can use 'template' instead of 'templateUrl' 
  .config(function($routeProvider){
                      $routeProvider.when('/students/:id',{
                        template:'<h1>hi this is students page</h1>'
                        controller: 'studentController',
                        controllerAs: 'studentCtrl'
                      })                    

* AngularJS route reload: We can use it in case we want to reload perticular route, using $route.reload()
  .controller('myController', function($scope, $http, $route){
    $scope.reloadData = function(){
      $route.reload();
    }
    $http.get('http://sdsdsdssdsd')
         .then(function(res){$scope.students = res.data});
  })
                      
* Cancel route change: If user navigates to other page we can show confirmation dialog box. When route change occurs it triggers two events '$routeChangeStart' and '$locationChangeStart'
  .controller('studentctrl', function($scope, $http, $route){
    $scope.$on('$routeChangeStart', function(event, next, current){
      if(!confirm('Are you sure, you want to go to ' + next.$$route.originalPath)){
        event.preventDefault(); <-- this function cancels the event
      }
    });
  });

* Routechange events:
  1. $locationChangeStart
  2. $routeChangeStart
  3. $locationChangeSuccess
  4. $routeChangeSuccess

* For logging purpose we can use $log service(inject it in controller and use it)
  -> $log.debug('$locationChangeStart event fired')

* Calling services from Angular: 
  .controller('studentctrl', function($scope, $http){
    $http.get('http://localhost:121/getstudent')
      .then(function(response){$scope.students = response.data}, 
          function(response){alert('Error occured' + response.status)});
  });
  --> then function is $http's promise which have both success and error callback functions. 

* We can also use 'this' keyword instead of '$scope', its called 'Controller as syntax'
  
  .controller('tutorialController', function(){
    this.courses = ['c#', 'SQL', 'Angular']
  });
  
  view--> <div ng-controller='tutorialController as tutoCtrl'>
            <div ng-repeat='course in tutoCtrl.courses'>
              {{course}}
            </div>
          </div>
          
  --> we can not use 'this' inside of inner functions, because it belongs to Windows object, but we can use in inner functions like below
  .controller('myController', function($http){
    var vm = this;
    $http.get('http://sdsdsds')
         .then(function(res){
          vm.students = res.data;
         });
  })
  
  --> for this purpose we can also use 'controllerAs' property
  .config(function($routeProvider){
                      $routeProvider.when('/students/:id',{ 
                        templateUrl:'templates/studentDetail.html'
                        controller: 'studentController',
                        controllerAs: 'studCtrl'
                      })
  --> by putting '?' in the parameter name we can make it optional
     $routeProvider.when('/students/:id?,{...
     
  --> to reduce complexity/confusion we can use controller as syntax feature

* Route resolve: This is a property available in 'when' function, using this property we can prevent the route for changing untill the data related to the requested route is completely loaded.
  The resolve property contiains one or more promises that must resolve successfully before transitioning to the new route.
  -->in .config
  .when('/students', {
    templateUrl:'Templates/students.html',
    controller: 'studentController',
    cotrollerAs: 'studCtrl',
    resolve:{
      studentList = function($http){
        return $http.get('http://sdasd/getallstudents')
                .then(function(response){
                return response.data;
                });
        }
    }
  })
  -->in .controller
  here 'studentList' property we can inject into the controller
  .controller('studentController',function(studentList){
    this.students = studentList;
    // we can remove $http.get from here because we have already placed it in 'resolve' property
  })
  
  example--old way using $scope
  <div ng-controller='countryController'> {{name}} --> India
  <div ng-controller='stateController'> {{$parent.name}}  - {{name}}  --> India - Maharashtra
  <div ng-controller='cityController'> {{$parent.$parent.name}} - {{$parent.name}} - {{name}} --> India - Maharashtra - Mumbai
  </div> </div> </div>
  
  example--new way using controller as syntax
  <div ng-controller='countryController as countryCtrl'> {{countryCtrl.name}} --> India
  <div ng-controller='stateController as stateCtrl'> {{countryCtrl.name}}  - {{stateCtrl.name}}  --> India - Maharashtra
  <div ng-controller='cityController as cityCtrl'> {{countryCtrl.name}} - {{stateCtrl.name}} - {{cityCtrl.name}} 
      --> India - Maharashtra - Mumbai
  </div> </div> </div>

*Service:
A special unit of code which can be used 

* Provider vs Factory vs Service vs value
- above all are the providers
- all of these will get executed only once, no matter how many times we inject it
- we have to define the function with the help of '$get' function
=> Provider
- provider can be accessed during configuration phase
- Provider -> provides some value
  var mod = angular.module('myModule',[]);
    mod.provider("myProvider", function() {
    this.$get = function() {
        console.log("MyProviderFunction.$get() called."); 
        return "My Value";
    };
  });

  mod.controller("MyController", function(myProvider) {
      console.log("MyController - myProvider: " + myProvider);
  });

  mod.controller("MyController2", function(myProvider) { 
      console.log("MyController2 - myProvider: " + myProvider);
  });

 => factory
 - for returning objects we can use it
 - for initializing objects with arguments passed in constructor, we can use factory
 - With a factory you just provide the function body for the $get method and Angular does the rest.
  mod.factory("myProvider", function() { // CHANGED “provider" to “factory"
      console.log("Factory function called.");
      return "My Value";
  });
  
  mod.controller("MyController", function(myProvider) {
      console.log("MyController - myProvider: " + myProvider);
  });
  
  mod.controller("MyController2", function(myProvider) {
      console.log("MyController2 - myProvider: " + myProvider);
  });
 
 - returning an object from a provider is not possible so, for this purpose we can use factory
 - Now there are several ways you can create an object in JavaScript, we’re going to use the “Object Constructor” approach where we create a function that populates an object with properties and functions and uses the new keyword to instantiate it.
 
  function MyObject() { // ADDED our object constructor
      this.getValue = function() {
          return "My Value";
      };
  }
  
  mod.factory("myProvider", function() {
      console.log("Factory function called.");
      return new MyObject(); // CREATE an instance of our object
  });
  
  mod.controller("MyController", function(myProvider) {
      console.log("MyController - myProvider: " + myProvider.getValue()); // CHANGED to call getValue()
  });
  
  mod.controller("MyController2", function(myProvider) {
      console.log("MyController2 - myProvider: " + myProvider.getValue()); // CHANGED to call getValue()
  });
   
 => Factory:
 A service is a special case of a factory when you want to return an instance of a new object, with the same benefit of writing less code.   
 
 => value
 module.value('myProvider','my value')
 - in canse we want to return literal values then we use it
 
 => constant
 module.constant('myProvider','my value')
 - only once we can assign the its value
 - we can access it during configuration

  => When to use one versus the other?
  The answer is you use the most specialize version that accomplishes your goal. Say for example you are returning an existing object defined somewhere else that takes constructor arguments. You can’t pass arguments to the service, so you would make the call with a factory instead.
  mod.factory("myProvider", function() {
      console.log("Factory function called.");
      return new SomeMessageBoxClass("custom argument");
  });
  
  => One of the main factors of deciding between a provider and factory is whether you want to be able to configure the object that is generated before it’s generated. You do this by calling module.config() and getting an instance to the provider itself (instead of the object returned by the provider). You do this by appending “Provider” to the end of your provider’s name when you are injecting it.

  Here is an example of how you would do that:
  mod.provider("myProvider", function() {
      this.value = "My Value";
  
      this.setValue = function(newValue) {
          this.value = newValue;
      };
  
      this.$get = function() {
          return this.value;
      };
  });
  
  mod.controller("MyController", function(myProvider) {
      console.log("MyController - myProvider: " + myProvider);
  });
  
  mod.config(function(myProviderProvider) { // ADDED config section
      // Note the extra "Provider" suffix
      myProviderProvider.setValue("New Value");
  });

* IIFE : 
  It’s an Immediately-Invoked Function Expression, or IIFE for short. It executes immediately after it’s created.
  
  It has nothing to do with any event-handler for any events (such as document.onload).
  The first pair of parentheses (function(){...}) turns the code within (in this case, a function) into an expression, and the second pair of parentheses (function(){...})() calls the function that results from that evaluated expression.
  
  This pattern is often used when trying to avoid polluting the global namespace, because all the variables used inside the IIFE (like in any other normal function) are not visible outside its scope.
  This is why, maybe, you confused this construction with an event-handler for window.onload, because it’s often used as this:
  
  (function(){
      // all your code here
      var foo = function() {};
      window.onload = foo;
      // ...
  })();
  // foo is unreachable here (it’s undefined)
  
  
  
  
  






