# Sotre architecture
  1. Data is not tied to any component, data belogs to store service 
  2. If component want data it need to subscribe to store, becasue store is observable 
  3. Components do not modify data directly, it has to be done via store
  4. In order to modify data component need to emit events (not commands) in form of actions.
  5. Store decides whether to modify data in server or in-memory, and it does it by reducers or effects. 
  Then emits new version of data.

# Store is a centralized singleton service, that acts as inmoemory database that contains whole applcation state. 
  In oerder to modify data we need to dispatch an action. 
  
# Reducer: Goal of a reducer fucntion is to calculate new store state in responce to a given action.

# Selector: All subscribers get values on any change in store, in order to get value from perticular change of value
 we can use selectors because it remembers the calculations.
  
  creating selector ///auth.selectors.ts 
  import {createSelector} from '@ngrx/store'
  
  export const selectAuthState = state => state.auth; //one selector
  export const isLoggedIn = createSelector(
    selectAuthState, //here we can inject multiple selectores 
    auth => auth.loggedIn //this is projection, retrun value
  );
  
  export const isLoggedOut = createSelector(
  isLoggedIn,
  loggedIn => !loggedIn
  );
  
  ///use selector
  import {select, Store} from '@ngrx/store'
  import {isLoggedIn} from './auth/auth.selectors';
  
  class Abc..
  isLoggedIn$: Observable<boolean>;
  ngOnInit(){
    this.isLoggedIn$ = this.store.pipe(
      select(isLoggedIn)
    );
  }
  
 # effects: These are the side effects provided by ngrx, using these we can perform another action as an effect of 
  one action. Eg make a db call apart from storing the data in store
  
  -- scaffold
  > ng g effect auth/Auth --module auth/auth.module.ts
  
  
  
  
  
  
  
  
  
  
  
  
